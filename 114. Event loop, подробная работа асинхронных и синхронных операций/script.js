'use strict';

/* console.log(1);

setTimeout(() => { console.log('time4000'); }, 4000);
setTimeout(() => { console.log('time1000'); }, 1000);

console.log(2); */
//если у таймаутов одинаковое время, сначала выполниться тот что первее

//ассинхронные операции
//timeout и timeInterval
//запросы на сервер
//колбеки

//call stack - какие вызовы привели к данному результату
//call stack - это те операции / вызовы функций, которые выполняются в данный момент

//webapis - хранилище для промежуточных данных, например надо записаться что
//функция в settimeout выполнится через какое-то время - контейнер запоминает эту информацию
//когда мы навешиваем события, они сохраняются в хранилище

//синхронный код сразу попадает в call stack, так как в очереди первый

//callback queue - все операции, которые выполняются в нашем браузере,
//становятся в очередь, а не выполняются параллельно

//задачи в очереди макрозадачи, а очередь - очередь макрозадач

//метод внутри коллбека не идет в очередь, а выполняется в call stack
//вызовы в очереди ждут, пока выполниться задача в call stack полностью
//например фореач будет выполняться, а события клики моментальные будут ждать

//трудозаемкая задача может заступорить всю страницу

let k = 0;

function count() {
  for (let i = 0; i < 1e9; i++) {
    k++;
  }
  alert(k);
}

count();
//пока это не отработает, страница не загрузится

//надо подразделять задачу на подзадачи

setTimeout(() => {
  console.log(1);
}, 0);//ставит 4 для совместимости между браузерами

// если запускаем сеттаймаут, он все равно проходит через асинхроный путь, а не сразу в очередь, так что сначала выполниться синхроный код
console.log(2);

//сеттаймаут с нулем используется как костыль
//чтобы выполнить определенные операции после синхронного кода

//допустим есть синхронный код который формирует элементы
//на основе сформированных элементов нам надо получить определенные
//параметры getComputedStyle 
